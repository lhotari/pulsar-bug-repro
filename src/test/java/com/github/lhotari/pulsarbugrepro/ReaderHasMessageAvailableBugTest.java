/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.lhotari.pulsarbugrepro;

import org.apache.pulsar.client.api.*;
import org.junit.jupiter.api.Test;
import org.testcontainers.containers.PulsarContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.*;

@Testcontainers
class ReaderHasMessageAvailableBugTest {
    @Container
    private static final PulsarContainer PULSAR = new PulsarContainer("2.5.0");
    private static final String TOPIC = "my-topic";

    @Test
    void shouldReadLastMessageWhenStartingAtLastMessageId() throws IOException, InterruptedException, ExecutionException, TimeoutException {
        PulsarClient pulsarClient = PulsarClient.builder()
                .serviceUrl(PULSAR.getPulsarBrokerUrl())
                .build();

        // create a subscription in the topic so that messages don't get discarded
        Consumer<String> consumer = pulsarClient.newConsumer(Schema.STRING)
                .topic(TOPIC)
                .subscriptionName("subscription-name")
                .subscribe();
        consumer.close();

        // produce some messages and collect the message ids
        Producer<String> producer = pulsarClient.newProducer(Schema.STRING)
                .topic(TOPIC)
                .create();
        List<String> words = Arrays.asList("Hello", "beautiful", "World!");
        List<MessageId> messageIds = words.stream().map((String message) -> {
            try {
                return producer.send(message);
            } catch (PulsarClientException e) {
                throw new RuntimeException(e);
            }
        }).collect(Collectors.toList());
        producer.close();

        // start reader at different indexes and verify that messages are read
        // this fails when the message id to start with is the last message in the topic
        for (int i = 0; i < words.size(); i++) {
            System.out.println("Setting startMessageId to the message id of the message at index " + i + "/" + words.size());
            readMessagesVerifyingIdAndBodyStartingAtIndex(i, words, messageIds, pulsarClient);
        }
    }

    private void readMessagesVerifyingIdAndBodyStartingAtIndex(int startIndex, List<String> words, List<MessageId> messageIds, PulsarClient pulsarClient) throws IOException, InterruptedException, ExecutionException, TimeoutException {
        try (Reader<String> reader = pulsarClient.newReader(Schema.STRING)
                .topic(TOPIC)
                .startMessageId(messageIds.get(startIndex))
                .startMessageIdInclusive()
                .create()) {
            for (int i = startIndex; i < words.size(); i++) {
                assertThat(reader.hasMessageAvailable()).as("should have next message available from index " + i + " when starting at index " + startIndex).isEqualTo(true);
                Message<String> message = reader.readNextAsync().get(1, TimeUnit.SECONDS);
                assertThat(message.getMessageId()).isEqualTo(messageIds.get(i));
                assertThat(message.getValue()).isEqualTo(words.get(i));
            }
            assertThat(reader.hasMessageAvailable()).as("there should be no more messages available").isFalse();
        }
    }
}
